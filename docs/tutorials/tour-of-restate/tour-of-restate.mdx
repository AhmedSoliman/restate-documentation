---
sidebar_position: 1
description: "Discover and learn Restate's key features."
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# A Tour of Restate

This tutorial guides you through the development of an end-to-end Restate application,
and covers all the essential features.
After this tutorial, you should have a firm understanding of how Restate can help you
and feel comfortable to tackle your next application on your own.

This tutorial implements a ticket reservation application for a theatre.
It allows users to add tickets for specific seats to their shopping cart.
After a ticket has been added, the seat is reserved for 15 minutes.
If it hasn't been bought and paid within that time interval, the reservation is released
and the ticket becomes available to other users.

The final application will have three services, each with a set of methods that will be implemented during the tutorial:
1. **User session service**: keeps track of which tickets are currently in the cart of the user. Implements:
    - AddTicket: adds a ticket to the shopping cart
    - Checkout: calls the checkout service to process the payment
    - ExpireTicket: sets tickets back to available, if they were not sold
2. **Ticket service**: manages all tickets that are being sold or have been sold. Implements:
    - Reserve: sets the status of a ticket to reserved
    - Unreserve: sets the status of a ticket to available
    - MarkAsSold: sets the status of a ticket to sold
3. **Checkout service**: handles the checkout process of the ticket sale. Implements:
    - Checkout: handles the checkout process

As we go, you will discover how Restate can help you with some intricacies in this application.

## Prerequisites
> &#x1F4DD; As long as Restate hasn't been launched publicly, you need to have access to the private Restate npm packages and Docker container. Please follow the instructions in the `restate-dist` Readme to set up access: https://github.com/restatedev/restate-dist

- [NodeJS (and npm)](https://nodejs.org) installed.
- [Docker Engine](https://docs.docker.com/engine/install/) to launch the Restate runtime (not needed for the app implementation itself).

## 🚀 Let's get started!

### Setting up the tutorial
Clone the GitHub repository of the [tutorial](https://github.com/restatedev/tour-of-restate-typescript) and checkout branch `part1`:
```shell
git clone git@github.com:restatedev/tour-of-restate-typescript.git
```

This GitHub repository contains the basic skeleton of the NodeJS/Typescript services that we develop in this tutorial. 

First, get all dependencies and build tools:
```shell
npm install
```

Next, generates the Typescript Protobuf code to help you write services according to your service contract.
```shell
npm run proto
```

Build the services:
```shell
npm run build
```

### Running the services and runtime
Run the services:
```shell
npm run app
```

This runs the services with `ts-node-dev` so the services will restart automatically when we save code changes.

Launch the runtime:
<Tabs groupId="operating-systems">
<TabItem value="lin" label="Linux">

```shell
docker run -e RUST_LOG=info,restate=info --network=host ghcr.io/restatedev/restate-dist:latest
```

</TabItem>
<TabItem value="mac" label="macOS">

```shell
docker run -e RUST_LOG=info,restate=info ghcr.io/restatedev/restate-dist:latest
```

</TabItem>
</Tabs>

Discover the services:
<Tabs groupId="operating-systems">
<TabItem value="lin" label="Linux">

```shell
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://localhost:8080"}'
```

</TabItem>
<TabItem value="mac" label="macOS">

```shell
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://host.docker.internal:8080"}'
```

</TabItem>
</Tabs>

You should now see the registered services printed out to your terminal:
```shell
{"services":["example.TicketService","example.UserSessionService","example.CheckoutService"]}
```

When we look at the logs of the runtime we see:
```
INFO restate_meta::service
  Discovered service
    rpc.service: "example.TicketService"
    restate.service_endpoint.url: http://localhost:8080/

INFO restate_meta::service
  Discovered service
    rpc.service: "example.UserSessionService"
    restate.service_endpoint.url: http://localhost:8080/

INFO restate_meta::service
  Discovered service
    rpc.service: "example.CheckoutService"
    restate.service_endpoint.url: http://localhost:8080/
```

Mimic adding a ticket to a cart, by calling the `AddTicket` method of the user session service as follows:
```shell
curl -X POST http://localhost:9090/example.UserSessionService/AddTicket -H 'content-type: application/json' -d '{"user_id": "123", "ticket_id": "456"}'
```
This gives us back a boolean return value:
```
true
```

If the value got printed, then you have a working setup.

### An overview of the project
In `src/app`, you find the skeleton of the ticket reservation app.
There is one file for each of the services and `app.ts` which contains the definition of the Restate server that will serve the RPC handlers.

The `proto/example.proto` file contains the service definitions.

Remember the curl command we did earlier?
```shell
curl -X POST http://localhost:9090/example.UserSessionService/AddTicket -H 'content-type: application/json' -d '{"user_id": "123", "ticket_id": "456"}'
```
The URL `http://localhost:9090` points to the ingress endpoint of the Restate runtime. This is then followed by `/package-name.service-name/method-name`.
In `proto/example.proto`, we defined `example` as the package name, `UserSessionService` as the service name, and `AddTicket` as one of the methods.
The data that is added to the request (i.e. `'{"user_id": "123", "ticket_id": "456"}'`) is the JSON representation of the messages that have been defined in `proto/example.proto`.

That's all you need to know right now about the Protobuf service definition. We will come back to this later.

### Exercise
After we have called the `addTicket` method to add items to the shopping cart,
we can call the `checkout` method of the user session service to go through with the purchase.
Try calling `checkout` method the for user id `123`. You will need this command later on.

<>
<details><summary>The answer</summary>

```shell
curl -X POST http://localhost:9090/example.UserSessionService/Checkout -H 'content-type: application/json' -d '{"user_id": "123"}'
```

</details>
</>

## Suspendable synchronous communication
One of the key parts of distributed applications is service-to-service communication.
Restate makes sure that service-to-service communication is durable.
RPCs or messages never get lost.

Let's begin with synchronous calls, in which one service calls another service and waits for the response.

When the `addTicket` method is called, it first needs to reserve the ticket for the user. It does that by calling the `reserve` method of the ticket service.

Let's have a look at how to do this in Restate. Add the highlighted code snippet to the `addTicket` method in the user session service.
```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    //highlight-start
    const ctx = restate.useContext(this);
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const success = await ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    );
    //highlight-end

    return success;
}
```

To interact with Restate, we need to retrieve the `RestateContext`. This is the entrypoint of all communication with the runtime. That is done in the first line of the code snippet:
```   typescript
const ctx = restate.useContext(this);
```

To resolve this, make sure you have the following import:
```typescript
import * as restate from "@restatedev/restate-sdk";
```

Once we have access to the `RestateContext`, we can call the ticket service.
For this, we use the client that was generated by `proto-ts`:

```typescript
const ticketServiceClient = new TicketServiceClientImpl(ctx);
const success = await ticketServiceClient.reserve(
  Ticket.create({ ticketId: request.ticketId })
);
```

We supply the RestateContext of the current invocation (`ctx`) to the client to make sure that it uses the SDK to send the requests.
Then we call the reserve method, which returns a BoolValue.

Let's see try it out. Run the services via `npm run app` and send a request to the `addTicket` method of the user session service, as we did [previously](#running-the-services-and-runtime).

Have a look at the SDK and runtime logs, to see how the ingress request triggers the execution of the `addTicket` and `reserve` methods.
This is what you should see in the SDK logs:

```
[restate] [2023-05-17T18:53:40.856Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Received input message.
[restate] [2023-05-17T18:53:40.857Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Adding message to output buffer: type: Invoke
[restate] [2023-05-17T18:53:40.859Z] [TicketService] [Reserve] [01882b0f-927a-7795-9416-09d03065ba8d] : Received input message.
[restate] [2023-05-17T18:53:40.860Z] [TicketService] [Reserve] [01882b0f-927a-7795-9416-09d03065ba8d] : Call ended successful with output message.
[restate] [2023-05-17T18:53:40.902Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Received new completion from the runtime.
[restate] [2023-05-17T18:53:40.902Z] [UserSessionService] [AddTicket] [01882b0f-9270-7ed5-ae40-7053890a3cd2] : Call ended successful with output message.
```

For this tutorial, we put the log level to debug by setting the environment variable `RESTATE_DEBUG_LOG=LOG`.
You can remove this environment variable in `package.json` to silence the logging.

### What actually happened?
The call we just did, seems like a regular RPC call.
But under-the-hood, Restate does a number of things to make sure that this call is durable.

The runtime persists the incoming request, establishes a connection to the user session service,
and sends the request over that connection.
All the communication between the runtime and the service, will go over this connection.
The service itself never needs to set up the connection.

The service then executes the method. When it calls the ticket service,
this request goes over the open connection to the runtime, that again durably logs it and invokes the ticket service.
The runtime takes care of request retries, in case of failures (covered later on in [Resiliency](#resiliency)).
Finally, the runtime delivers the response to the user session service.

When services need to wait a long time (e.g. sleep an hour, or wait for a day on a response),
Restate allows them to suspend and to free up the resources for other invocations.
When the service is able to resume, Restate invokes the service again and sends over a replay log.
The replay log contains the steps that the service already executed before it suspended.
The service replays the log and continues processing at the point where it left off.

:::tip
The suspension mechanism of Restate is especially beneficial if you run on serverless infrastructure (e.g. AWS Lambda).
For example, you can do synchronous calls without paying for the idle time when waiting for a response.
:::

To show this working in practice, let's mimic that the ticket service is doing some
processing for a certain amount of time by adding sleep call to the `reserve` method of
the ticket service:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //bad-code-start
    await setTimeout(5000);
    //bad-code-end
    return BoolValue.create({value: true});
}
```
Also add the import: `import { setTimeout} from "timers/promises";`.

:::caution
This is not the proper way to sleep in a Restate application!
The Restate SDK offers you a way to do sleeps that are suspendable, as covered [later on](#suspendable-sleep).
:::

Call the `addTicket` method of the user session service again and have a look at the SDK logs:
```
[restate] [2023-05-17T19:20:50.382Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Received input message.
[restate] [2023-05-17T19:20:50.385Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Adding message to output buffer: type: Invoke
[restate] [2023-05-17T19:20:50.389Z] [TicketService] [Reserve] [01882b28-6fd3-7091-b92b-b392071925c3] : Received input message.
[restate] [2023-05-17T19:20:51.389Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Call suspending.
[restate] [2023-05-17T19:20:55.394Z] [TicketService] [Reserve] [01882b28-6fd3-7091-b92b-b392071925c3] : Call ended successful with output message.
[restate] [2023-05-17T19:20:55.397Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Received input message.
[restate] [2023-05-17T19:20:55.398Z] [UserSessionService] [AddTicket] [01882b28-6fc3-7f6e-8cd1-c4dfe5983e21] : Call ended successful with output message.
```
Now that the the ticket service responds later, we see that the `addTicket` method suspends.
Once the runtime has received the response, it invokes the `addTicket` method again and the call finishes.

Remove the sleep again, before you continue.

[//]: # (TODO include a video demo of knative on minikube to show how containers are spun up and torn down.)

## Reliable async communication without queues

The call in the `addTicket` method waited for a response (albeit in suspended mode).
You can also do async calls via Restate, where you do not wait for the response. The syntax is very similar.
All we need to do is wrap the call with `inBackground`, as follows:

```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);
    //highlight-start
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    await ctx.inBackground(() =>  ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    ));
    //highlight-end

    return BoolValue.create({ value: true });
}
```

Make sure both services are running, as [explained earlier](#running-the-services-and-runtime).
Then call the `addTicket` method of the user session service.

If you look at the logs of the runtime, you see that the `addTicket` method doesn't wait for a response and finishes before the `reserve` method.

## Awakeables
TODO: not yet included in the ticket reservation example

Synchronous and asynchronous calls tie services together and allow executing workflows by having several services execute parts of it.
The calls we did until now were always in between Restate services.
But what if you want to do a part of the tasks in an external service.
For example, you want a Restate service to put a message on Kafka, have it ingested by a non-Restate service.
Do some processing. And then invoke the Restate service again to continue its work. For this, you could use awakeables.
This works similar as what is known as the callback task token pattern. You generate an ID.
You supply that ID to the external service. Once the external service is done with the work, it sends the ID back to Restate.
And when Restate receives the ID, it continues processing.

So how can you do this with the Typescript SDK?

```typescript
const awakeable = ctx.awakeable<string>();

const id = awakeable.id

// send the ID to some external system

// Await on the ID to be send back to the runtime
const result = await awakeable.promise;
```

Calling `ctx.awakeable` gives you an object with two entries. A String ID and a promise. The promise gets resolved with a payload that the external service can attach to it.
You need to supply the data return type when you create the awakeable. In this case, the return payload will be a String.

Similar to synchronous and asynchronous communication, the function is suspended while it is waiting on the return of the ID.

## Durable timers
As we explained earlier, Restate suspends a service invocation when it's waiting on external input.
The partial progress of the service invocation is durable stored in the log and can be resumed once
the external input has arrived.
Restate offers the same mechanism for timers.

### Suspendable sleep
You can do a durable, suspendable sleep with the Typescript SDK.
Earlier in this tutorial, we showed how Restate suspensions work by letting the ticket service sleep:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //bad-code-start
    await setTimeout(5000);
    //bad-code-end
    return BoolValue.create({value: true});
}
```
This line of code would keep the service invocation running idly, and would not survive service restarts.

To use a durable, suspendable sleep, use the sleep functionality of the Restate SDK:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //good-code-start
    await ctx.sleep(5000);
    //good-code-end
    return BoolValue.create({value: true});
}
```

Run both services and send the `addTicket` request, as [we did earlier](#running-the-services-and-runtime).
Now we see that both services get suspended. The user session service gets suspended because it does a
synchronous call to the `reserve` method of the ticket service and waits for a response and the
ticket service gets suspended because it waits for the sleep to be completed.

Restate keeps track of how long the service should sleep and then resumes the invocation.
Once the invocation has been resumed, we see the responses of both methods coming in.

:::caution
Sleeping can block processing for certain types of Restate services (keyed and singleton
services). We get back to this in the [concurrency](#concurrency) section.
:::

TODO: show this on minikube with knative in a little video

### Delayed calls

Let's have a look at a slightly different usage of timers.
In our application, we want a ticket to be reserved for 15 minutes.
If it hasn't been bought and paid within that time interval, then it becomes available again to other users.


The Restate SDK allows doing delayed async calls by adding a delay in milliseconds to the
`inBackground` wrapper.
```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const reserveResult: BoolValue = await ticketServiceClient.reserve(
      Ticket.create({ ticketId: request.ticketId })
    );

    if (reserveResult.value) {
        //highlight-start
      await ctx.inBackground(() =>
        ticketServiceClient.unreserve(
          ExpireTicketRequest.create({
            userId: request.userId,
            ticketId: request.ticketId,
          })
        ),
        15 * 60 * 1000 // 15 minutes delay
      );
      //highlight-end
    }

return BoolValue.create({ value: true });
}
```

To test it out, put the delay to a lower value (e.g. 10 seconds) and see how the call comes in later.

:::caution
Another way to implement this, would be to sleep for 15 minutes at the end of the `addTicket` method
and then call the  `unreserve` method of the ticket service.

```typescript
await ctx.sleep(15 * 60 * 1000);
await ctx.inBackground(() =>
ticketServiceClient.unreserve(
  ExpireTicketRequest.create({
    userId: request.userId,
    ticketId: request.ticketId,
  })
));
```
But this would block any invocations for that key. So the user would not be able to add any other tickets, nor buy
the tickets.
:::

## Concurrency
Earlier, we covered Restate's sleep functionality and we mentioned keyed, unkeyed, and singleton services. Let's
have a look at what they are.

There are three types of Restate services:
1. **Keyed service**: All service invocations are sharded on a user-defined key. There is at most one concurrent
invocation per key.
2. **Unkeyed service**: No key defined. No concurrency guarantees or limitations. Invocations are processed as they
come in. You would get the same behavior with a keyed service with random keys.
3. **Singleton service**: No key defined. There is at most one concurrent invocation for this entire service. You can
see this as a keyed service where all invocations have an identical key. This service type does not scale up, so
don't use it for heavy load.

### Specifying the service type
Restate uses [gRPC](https://grpc.io/) and [Protobuf](https://protobuf.dev/) to define service contracts.
That's also where you define the service type and key.
Have a look at the Protobuf definitions of the ticket service of our example in `proto/example.proto`:
```protobuf
service TicketService {
  //highlight-next-line
	option (dev.restate.ext.service_type) = KEYED;

	rpc Reserve (Ticket) returns (google.protobuf.BoolValue);
    //... other methods...
}

message Ticket {
  //highlight-next-line
	string ticket_id = 1 [(dev.restate.ext.field) = KEY];
}
```

The first highlighted line of the service definition defines the type of Restate service.
The ticket service is a keyed service. For unkeyed or singleton services, use `UNKEYED` and `SINGLETON` respectively.

Keyed services require the definition of a key, in the second highlighted line.
The key should correspond to one of the fields in the input request.
You specify the key by adding the `[(dev.restate.ext.field) = KEY]` annotation.
Make sure that you define the key field for all the methods of a keyed service!

Besides these tags, there is nothing Restate-specific about the Protobuf definitions.
To learn more about gRPC, have a look at their [documentation](https://grpc.io/docs/).

:::caution
Keyed services and singleton services have limits on the number of concurrent invocations.
For keyed services, there is a maximum of one concurrent invocation per key.
For singleton services, there is a maximum of one concurrent invocation for the entire
service.
This can lead to issues:
- If you do an operation that takes a lot of time in a keyed/singleton service (e.g.
sleep), then that key/service remains blocked during the entire operation. Other
invocations for that key/service are enqueued, until the invocation has completed.
- Deadlocks: Watch out for cyclical synchronous calls in your application.
For example, if A calls B, and B calls C, and C calls A again, then you can
get into a deadlock situation, where each service is waiting for the response of the
other and none of them can progress. The keys remain locked and the system can't
process any more requests.
:::

:::tip
You can also use the concurrency guarantees of keyed and singleton services to your
advantage! The guarantee that there is only a single ongoing invocation makes
it a lot easier to reason about interaction with external systems.

Imagine an application where you have a keyed service and a database.
And every key only interacts with an isolated set of rows of the database.
Then you can easily scale up your application, while being sure that there will only be a
single writer to that database row. This solves a lot of data consistency issues for
you, such as lost updates or non-repeatable reads.

For example, a shopping cart application has a product service that is keyed on product ID
and a database that uses product ID as the primary key. The product service updates
quantities and prices in the database. With Restate, you can be sure that there is at
most one ongoing invocation updating a single product in the database.
:::

### Exercise
If you are not well acquainted with gRPC, then you can do this little exercise to get
some training. Otherwise, just copy over the answers to continue with the tutorial.

Let's add a new service to our example: the `CheckoutService`.
This service will handle checkout requests and makes sure that the payment is done exactly one time,
that the product is marked as sold and that a confirmation email is sent.
The service can be an unkeyed service and has a `Checkout` method that takes a `CheckoutFlowRequest` and returns a
`BoolValue`, denoting whether the checkout was successful.

The `CheckoutFlowRequest` has two fields: a String describing the `user_id` and an array of Strings describing the
`tickets` that are bought.

Run the `npm` command to generate the related Typescript code and write the skeleton
of the checkout service.

<>
<details><summary>The answer</summary>
The service definition in `proto/example.proto` should look as follows:

```protobuf

service CheckoutService {
    option (dev.restate.ext.service_type) = UNKEYED;

    rpc Checkout (CheckoutFlowRequest) returns (google.protobuf.BoolValue);
}

message CheckoutFlowRequest {
    string user_id = 1;
    repeated string tickets = 2;
}

```

Note that unkeyed services don't have a key specified in the message.

Write the skeleton of the service in `src/checkout_service`, similar to the other
services.

</details>
</>

## Persistent application state

Applications often need to keep some form of state. For example, our user session
needs to keep track of the items in the shopping cart.

Restate offers a key-value store to persistently store application state.
The state is guaranteed to be consistent across retries and invocations.
This eliminates the need for a session database such as Redis.

The isolation level of the application state depends on the service type:
1. Keyed service: Application state is isolated per key. All the invocations for the
same key have access to the same application state. Restate's state feature is most
useful for
this service type.
2. Singleton service: Since there are no keys, all invocations to the service can access
the same state.
3. Unkeyed service: State is isolated per invocation. Using state is least useful
for this service type.

Let's adapt the `addTicket` method to keep track of the items in the shopping cart.

When reserving the product in the ticket service was a success, then we want to add
the ticket to the shopping cart. Have a look at the highlighted code:

```ts
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const reserveResult: BoolValue = await ticketServiceClient.reserve(
      Ticket.create({ ticketId: request.ticketId })
    );

    if (reserveResult.value) {
        //highlight-start
        const cart = (await ctx.get<string[]>("cart")) || [];
        cart.push(request.ticketId);
        ctx.set("cart", cart);
        //highlight-end

        // Delayed expiration call
        await ctx.inBackground(
          //...
        );
    }

return BoolValue.create({ value: true });
}
```

To read the state, we simply did:

```typescript
const cart = await ctx.get<string[]>("cart") || [];
```

You can store multiple key-value pairs for a single invocation key.
Here, we get the value under the key `"cart"`.
Restate will return the `"cart"` value for the current invocation key.

After we added the ticket to the cart array, we set the state to the new value with:

```typescript
ctx.set("cart", cart);
```

Later on in the tutorial, when we implement the checkout flow,
we will empty the cart with:
```typescript
ctx.clear("cart")
```

:::caution
You can store any object in the state as long as the value can be serialized with
`Buffer.from(yourObject)`.
:::

[//]: # (TODO add some text on how to run this and print the state )


### Exercise
Store the status of the tickets in the ticket service in state. Do the exercises
listed below and check your implementation by running the service and calling the method.

1. Implement the `reserve` method of the ticket service.
The method should first retrieve the value for the `ticket_status` state key.
If the value is set to `"AVAILABLE"` then it should change it to `RESERVED` and
return `true` (reservation successful). If the status is not set to `"AVAILABLE"` then it
should return `false`.

<>
<details><summary>The answer</summary>

```ts
async reserve(request: Ticket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const ticketStatus = await ctx.get<string>("ticket_status");

    if(!ticketStatus || ticketStatus === "AVAILABLE"){
        ctx.set("ticket_status", "RESERVED")
        return BoolValue.create({ value: true });
    } else {
        return BoolValue.create({ value: false });
    }
}
```

</details>
</>

2. Implement the `unreserve` method of the ticket service. The method should set the
value of the `"ticket_status"` key to `"AVAILABLE"`.

<>
<details><summary>The answer</summary>

```ts
async unreserve(request: Ticket): Promise<Empty> {
    const ctx = restate.useContext(this);

    ctx.set("ticket_status", "AVAILABLE");

    return {};
}
```

</details>
</>

3. Implement the `markAsSold` method of the ticket service. The method should set the
value of the `"ticket_status"` key to `"SOLD"`.


<>
<details><summary>The answer</summary>

```ts
async unreserve(request: Ticket): Promise<Empty> {
    const ctx = restate.useContext(this);

    ctx.set("ticket_status", "AVAILABLE");

    return {};
}
```

</details>
</>


## Side effects
In the beginning of this tutorial, we explained the replay mechanism of Restate.
This mechanism makes Restate applications resilient to failures.
But it also requires your code to be deterministic.

If you need to execute a non-deterministic code snippet (e.g. generating a UUID or
communicating to an external system) then you need to wrap it in a side effect.

The side effect executes the supplied function and eagerly stores the return value in
Restate. Upon replay, the stored value gets inserted and the function does not get
re-executed.

Let's show how you can use this in the `checkout` method of the checkout service to
create and store a UUID or idempotency key:
```typescript
async checkout(request: CheckoutFlowRequest): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    //highlight-start
    const idempotencyKey = await ctx.sideEffect<string>(async () => uuid());
    //highlight-end

    return BoolValue.create({ value: true });
}
```

The highlighted line of code wraps the creation of the UUID in a side effect
    with a string return type. When the `checkout()` method gets re-executed upon
    replay, Restate will inject the stored value.


### Exercise
The `checkout` method triggers the payment via some external payment provider, e.g.
Stripe. You can find a Stripe client stub in `src/aux/stripe_client.ts`. The Stripe
client has two methods:

- `get()` to create a new client,
- `call(idempotencyKey: string, amount: number)` to execute the payment for a certain
    idempotencyKey and total amount. Stripe makes sure that only one payment gets processed for a single
idempotency key.

Create a new Stripe client in the `checkout` method of the checkout service. Then do the
    payment
    with the created idempotency key and store the boolean result of the
    call as a side effect.

<>
<details><summary>The answer</summary>

```typescript
async checkout(request: CheckoutFlowRequest): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const idempotencyKey = await ctx.sideEffect<string>(async () => uuid());

//highlight-start
    const stripe = StripeClient.get();

    const success = await ctx.sideEffect<boolean>(async () =>
        await stripe.call(idempotencyKey, amount)
    );
        //highlight-end

    return BoolValue.create({ value: true });
}
```

</details>
</>

Once the Stripe call has been stored successfully in Restate, it will not get executed
    again.


## Resiliency
Restate makes your applications resilient out-of-the-box.

- It makes sure message can't get lost by durably storing all calls in the log. No
    more queues needed for async calls.
- It retries failed invocations based on a specified retry policy. No more retry logic
    required for inter-service communication.
- It restores partial progress of invocations, via its durable execution mechanism. For
    example, if a service goes down due to an infrastructure failure, the ongoing
    invocations will resume at the point in the user code where they left off.
- It ensures consistent application state with its key-value store.
- End-to-end exactly once guarantees for incoming invocations.

### Runtime configuration
You can tune the default retry policies of the runtime via the configuration.


  => show in the logs

### SDK utilities for retries

The Typescript SDK includes some utilities to retry side effects


```typescript
const doPayment = async () => stripe.call(idempotencyKey, amount);
const success: boolean = await RestateUtils.retryExceptionalSideEffectWithBackoff(ctx, doPayment, 100, 500)
```

## Observability
Tracing with Jaeger
Enabling tracing

Having a look at the traces.

## 🏁 The end
You reached the end of this tutorial!

Let's recap what we covered:
- reliable synchronous calls that can be suspended
- asynchronous calls without the need for queues
- suspensions for external communication
- awakeables: how to do tasks in external systems and resume processing
- durable timers for sleep or for calling other services
- concurrency guarantees of restate for keyed/unkeyed/singleton services
- persistent application state
- state introspection
- storing the results of non-deterministic operations or external calls as side effects
- resiliency: retries
- observability with Jaeger

Have a look at the fully implemented service here: XXXXXXXXXXXXXXXXXX

## Next steps
This tutorial did not cover anything related to deployment. 
In this tutorial, we ran the services as long-running services in Docker containers.
But Restate services can run with minimal changes on AWS Lambda. 

Have a look at these follow-up tutorials:
- Deployment on AWS Lambda
- Deployment on Kubernetes (minikube)




