---
sidebar_position: 1
description: "Discover and learn Restate's key features."
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# A Tour of Restate
**This is work in progress...**

To get you started with Restate, this tutorial will help you develop an end-to-end example, covering all important Restate features.
After this tutorial,
you should have a firm understanding of how Restate can help you
and feel comfortable to tackle your next application on your own.

This tutorial implements a ticket reservation application for a theatre.
You can see it as a subset of the services of a larger e-commerce application.
Users can add tickets for specific seats to their shopping cart.
After a ticket has been added, the seat is reserved for 15 minutes.
If it hasn't been bought and paid within that time interval, then it becomes available again to other users.

The final application will have three services:
1. User session service: keeps track of which tickets are currently in the cart of the user. 
2. Ticket service: manages all tickets that are being sold or have been sold. 
3. Checkout service: handles the checkout process of the ticket sale. This service will be added later on in the tutorial.

As we go, you will discover how Restate can help you with some intricacies in this application.

## Prerequisites
> &#x1F4DD; As long as Restate hasn't been launched publicly, you need to have access to the private Restate npm packages and Docker container. Please follow the instructions in the `restate-dist` Readme to set up access: https://github.com/restatedev/restate-dist

- [NodeJS (and npm)](https://nodejs.org) installed.
- [Docker Engine](https://docs.docker.com/engine/install/) to launch the Restate runtime (not needed for the app implementation itself).

## 🚀 Let's get started!

### Setting up the tutorial
Clone the GitHub repository of the [tutorial](https://github.com/restatedev/tour-of-restate-typescript) and checkout branch `part1`:
```shell
git clone git@github.com:restatedev/tour-of-restate-typescript.git
git checkout part1
```

This GitHub repository contains the basic skeleton of the NodeJS/Typescript services that we develop in this tutorial. 

First, get all dependencies and build tools:
```shell
npm install
```

Next, generates the Typescript Protobuf code to help you write services according to your service contract.
```shell
npm run proto
```

Build the services:
```shell
npm run build
```

### Running the services and runtime
Run the user session service:
```shell
npm run user_session_service
```

In a separate terminal, run the ticket service:
```shell
npm run ticket_service
```

Launch the runtime:
<Tabs groupId="operating-systems">
<TabItem value="lin" label="Linux">

```shell
docker run -e RUST_LOG=info,restate=info --network=host ghcr.io/restatedev/restate-dist:latest
```

</TabItem>
<TabItem value="mac" label="macOS">

```shell
docker run -e RUST_LOG=info,restate=info ghcr.io/restatedev/restate-dist:latest
```

</TabItem>
</Tabs>


Discover the services:
<Tabs groupId="operating-systems">
<TabItem value="lin" label="Linux">

```shell
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://localhost:8080"}'
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://localhost:8082"}'
```

</TabItem>
<TabItem value="mac" label="macOS">

```shell
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://host.docker.internal:8080"}'
curl -X POST http://localhost:8081/services/discover -H 'content-type: application/json' -d '{"uri": "http://host.docker.internal:8082"}'
```

</TabItem>
</Tabs>

You should now see the registered services printed out to your terminal:
```shell
{"services":["example.UserSessionService"]}
{"services":["example.TicketService"]}
```

When we look at the logs of the runtime we see:
```
2023-05-15T14:36:03.767790Z INFO restate_meta::service
  Discovered service
    rpc.service: "example.UserSessionService"
    restate.service_endpoint.url: http://localhost:8080/

2023-05-15T14:36:06.224985Z INFO restate_meta::service
  Discovered service
    rpc.service: "example.TicketService"
    restate.service_endpoint.url: http://localhost:8082/
```


Mimic adding a ticket to a cart, by calling the `AddTicket` method of the user session service as follows:
```shell
curl -X POST http://localhost:9090/example.UserSessionService/AddTicket -H 'content-type: application/json' -d '{"user_id": "dkd111", "ticket_id": "Rolling-stones-A22"}'
```
This gives us back a boolean return value:
```
true
```

If the value was printed successfully, then you have a working setup. 

The repository that you cloned, contains the basis of the ticket reservation app. When you look at the `src` folder you see two Typescript files: `ticket_service.ts` and `user_session_service.ts`.

Both files contain the skeleton of a Restate service with some empty methods defined in it. 
These methods will be implemented throughout the tutorial.

The services and methods, that are exposed as RPC handlers to the runtime, are defined in the `example.proto` file. 

Remember the curl command we did earlier?
```shell
curl -X POST http://localhost:9090/example.UserSessionService/AddTicket -H 'content-type: application/json' -d '{"user_id": "123", "ticket_id": "456"}'
```
The URL `http://localhost:9090` points to the ingress endpoint of the Restate runtime. This is then followed by `/package-name.service-name/method-name`. In `proto/example.proto`, we defined `example` as the package name, `UserSessionService` as the service name, and `AddTicket` as one of the methods. The data that is added to the request (i.e. `'{"user_id": "123", "ticket_id": "456"}'`) is the JSON representation of the messages that have been defined in `proto/example.proto`.

That's all you need to know right now about the Protobuf service definition. We will come back to this later.

Try calling some other methods and let's then move on to implementing our first Restate service. 

## Suspendable synchronous communication
One of the key parts of distributed applications is service-to-service communication. 

Let's start with synchronous calls, where a service calls another service and waits for the response. 

### Synchronous calls
When the user adds a ticket to his cart, this invokes the `addTicket` method in the user session service.
The `addTicket` method first needs to reserve the ticket if it is available. It does that by calling the `reserve` method of the ticket service.

Let's have a look at how to do this in Restate. Add the highlighted code snippet to the `addTicket` method in the user session service.
```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    //highlight-start
    const ctx = restate.useContext(this);
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const success = await ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    );
    //highlight-end

    return success;
}
```

To interact with Restate, we need to retrieve the `RestateContext`. This is the entrypoint of all communication with the runtime. That is done in the first line of the code snippet:
```   typescript
const ctx = restate.useContext(this);
```

To resolve this, make sure you have the following import:
```typescript
import * as restate from "@restatedev/restate-sdk";
```

Once we have access to the `RestateContext`, we can call the ticket service.
For this, we need to create a client for the ticket service. 

```typescript
const ticketServiceClient = new TicketServiceClientImpl(ctx);
```

We supply the RestateContext of the current invocation (`ctx`) to the client to make sure that it sends the requests to Restate, in a way that Restate understands them.

The client is an instance of the `proto-ts` client that was generated when we ran `npm run proto` earlier.
We can now use this client to call the `reserve`  method of the ticket service as follows:

```typescript
const success = await ticketServiceClient.reserve(
  Ticket.create({ ticketId: request.ticketId })
);
```
The reserve method returns a BoolValue that is equal to `true` if the ticket reservation was successful.

Let's see if this works.

Make sure that both services are running and send a request to the `addTicket` method of the user session service, as we did [previously](#running-the-services-and-runtime).

Have a look at the Restate runtime logs, to see how our ingress request is processed and triggers the execution of the `addTicket` and `reserve` methods.

### What actually happened?
The call we just did, seems like a regular RPC call. But under-the-hood, Restate does a number of things to make sure that this call is executed durably and ...

When we do a call like this, a series of steps get executed.
- The runtime receives our request and persists it.
- The runtime establishes a connection to the user session service.
- The runtime invokes the service method, by sending the request over the connection.
- The user session service starts executing the `addTicket` method.
- The user session service then sends a request to the ticket service. It sends this request over the open connection to the runtime. 
- The response of the other service can take long so the user session service suspends.
- The runtime durably logs the call.
- The runtime forwards the connection to the ticket service. (Note: the runtime makes sure these requests are done and takes care of retries. The details on retries will be covered later. )
- Once the runtime has received the response, it wakes up the user session service. 
- The code gets replayed up to the point of the request. And then the rest of the method gets executed.

The suspension mechanism of Restate is especially beneficial if you run with AWS Lambda.
You can do synchronous calls without paying for the idle time when waiting for a response.
But also for long-running services this system can be helpful because Restate makes sure that an invocation is durably recorded and can survive any failures.

To show how this works in practice and mimic that the ticket service is doing some processing for a certain amount of time, we can add a sleep call to the `reserve` method of the ticket service.
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //bad-code-start
    await setTimeout(5000);
    //bad-code-end
    return BoolValue.create({value: true});
}
```
Then run the example and call the `addTicket` method, which calls the `reserve` method.
Show in the logs that the `addTicket` method gets suspended for 5 seconds.

:::caution
This is not the proper way to sleep in a Restate application! The Restate SDK offers you a way to do sleeps that are suspendable! Read on to find out how to do this.
:::

Explain how replay works.

Maybe include a little video demo of knative on minikube to show how containers are spun up and torn down.

## Reliable async communication without queues

The calls we did in the previous section, always waited for a response to the request (albeit in suspended mode).
You can also do async calls via Restate, where you do not wait for the response. The syntax is very similar.
All we need to do is wrap the call with `inBackground`, as follows:

```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);
    //highlight-start
    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    await ctx.inBackground(() =>  ticketServiceClient.reserve(
        Ticket.create({ ticketId: request.ticketId })
    ));
    //highlight-end

    return BoolValue.create({ value: true });
}
```

Make sure both services are running, as [explained earlier](#running-the-services-and-runtime).
Then call the `addTicket` method of the user session service.

If you look at the logs of the runtime, you see that the `addTicket` method doesn't wait for a response and finishes before the `reserve` method.

## Awakeables
TODO: not yet included in the ticket reservation example

Synchronous and asynchronous calls tie services together and allow executing workflows by having several services execute parts of it.
The calls we did until now were always in between Restate services.
But what if you want to do a part of the tasks in an external service.
For example, you want a Restate service to put a message on Kafka, have it ingested by a non-Restate service.
Do some processing. And then invoke the Restate service again to continue its work. For this, you could use awakeables.
This works similar as what is known as the callback task token pattern. You generate an ID.
You supply that ID to the external service. Once the external service is done with the work, it sends the ID back to Restate.
And when Restate receives the ID, it continues processing.

So how can you do this with the Typescript SDK?

```typescript
const awakeable = ctx.awakeable<string>();

const id = awakeable.id

// send the ID to some external system

// Await on the ID to be send back to the runtime
const result = await awakeable.promise;
```

Calling `ctx.awakeable` gives you an object with two entries. A String ID and a promise. The promise gets resolved with a payload that the external service can attach to it.
You need to supply the data return type when you create the awakeable. In this case, the return payload will be a String.

Similar to synchronous and asynchronous communication, the function is suspended while it is waiting on the return of the ID.

## Durable timers
As we explained earlier, Restate suspends a service invocation when it's waiting on external input.
The partial progress of the service invocation is durable stored in the log and can be resumed once
the external input has arrived.
Restate offers the same mechanism for timers.

### Suspendable sleep
You can do a durable, suspendable sleep with the Typescript SDK.
Earlier in this tutorial, we showed how Restate suspensions work by letting the ticket service sleep:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //bad-code-start
    await setTimeout(5000);
    //bad-code-end
    return BoolValue.create({value: true});
}
```
This line of code would keep the service invocation running idly, and would not survive service restarts.

To use a durable, suspendable sleep, use the sleep functionality of the Restate SDK:
```typescript
async reserve(request: Ticket): Promise<BoolValue> {
    //good-code-start
    await ctx.sleep(5000);
    //good-code-end
    return BoolValue.create({value: true});
}
```

Run both services and send the `addTicket` request, as [we did earlier](#running-the-services-and-runtime).
Now we see that both services get suspended. The user session service gets suspended because it does a
synchronous call to the `reserve` method of the ticket service and waits for a response and the
ticket service gets suspended because it waits for the sleep to be completed.

:::caution
As you will learn in the section on [concurrency](#concurrency), Restate has the concept of keyed services.
In these services, all the invocations for a specific key are guaranteed to be executed sequentially.
This means that the max number of concurrent invocations for a single key is one.
When you sleep in a keyed service, that invocation will be blocking any other invocations for the same key.
So be careful with sleeping in keyed services and singleton services!
You can use it in unkeyed services without any worries.
:::

Restate keeps track of how long the service should sleep and then resumes the invocation.
Once the invocation has been resumed, we see the responses of both methods coming in.

TODO: show this on minikube with knative in a little video

### Delayed calls

Let's have a look at a slightly different usage of timers.
In our application, we want a ticket to be reserved for 15 minutes.
If it hasn't been bought and paid within that time interval, then it becomes available again to other users.


The Restate SDK allows doing delayed async calls by adding a delay in milliseconds to the
`inBackground` wrapper.
```typescript
async addTicket(request: ReserveTicket): Promise<BoolValue> {
    const ctx = restate.useContext(this);

    const ticketServiceClient = new TicketServiceClientImpl(ctx);
    const reserveResult: BoolValue = await ticketServiceClient.reserve(
      Ticket.create({ ticketId: request.ticketId })
    );

    if (reserveResult.value) {
        //highlight-start
      await ctx.inBackground(() =>
        ticketServiceClient.unreserve(
          ExpireTicketRequest.create({
            userId: request.userId,
            ticketId: request.ticketId,
          })
        ),
        15 * 60 * 1000 // 15 minutes delay
      );
      //highlight-end
    }

return BoolValue.create({ value: true });
}
```

To test it out, put the delay to a lower value (e.g. 10 seconds) and see how the call comes in later.

:::caution
Another way to implement this, would be to sleep for 15 minutes at the end of the `addTicket` method
and then call the  `unreserve` method of the ticket service.

```typescript
await ctx.sleep(15 * 60 * 1000);
await ctx.inBackground(() =>
ticketServiceClient.unreserve(
  ExpireTicketRequest.create({
    userId: request.userId,
    ticketId: request.ticketId,
  })
));
```
But this would block any invocations for that key. So the user would not be able to add any other tickets, nor buy
the tickets.
:::

## Concurrency
Earlier, we covered Restate's sleep functionality and we mentioned keyed, unkeyed, and singleton services. Let's
have a look at what they are.

There are three types of Restate services:
1. **Keyed service**: All service invocations are sharded on a user-defined key. There is at most one concurrent
invocation per key.
2. **Unkeyed service**: No key defined. No concurrency guarantees or limitations. Invocations are processed as they
come in. You would get the same behavior with a keyed service with random keys.
3. **Singleton service**: No key defined. There is at most one concurrent invocation for this entire service. You can
see this as a keyed service where all invocations have an identical key. This service type does not scale up, so
don't use it for heavy load.

The service type and key are defined in the Protobuf definition of the service. 



- writing the proto files
=> how to write them, keyed/unkeyed/singleton, key specification
Add checkout service

Sleeping blocks the key of a keyed service

## Persistent application state
In our user session we actually also want to keep track of which tickets were reserved by the user. 

For this we can use application state. 

When the user calls the addTicket method, we also want it to save the ticket in the userSession shopping cart.
We don't need a session database such as Redis for this. We can use the Restate application state to persistently
store the application state.
Currently we support key value state.
To read the state, do the following

```typescript
const cart = await ctx.get<string[]>("cart") || [];
```

Then we add the ticket and set the state to the new value:

```typescript
cart.push(request.ticketId);
ctx.set("cart", cart);
```

Add a clear cart method with clear state:
```typescript
ctx.clear("cart")
```

## State introspection
Read the state via the CLI to check what is currently in the state. 


## Side effects
Because of the retries due to resiliency we sometimes need to save something.

```typescript
const stripe = StripeClient.get();

const idempotencyKey = await ctx.sideEffect<string>(async () => uuid());

await ctx.sideEffect<boolean>(async () => await stripe.call(idempotencyKey, amount));
```

## Resiliency

### Runtime configuration
  => configuring retries, retryWithBackoff,

  => show in the logs

### SDK utilities for retries

```typescript
const doPayment = async () => stripe.call(idempotencyKey, amount);
const success: boolean = await RestateUtils.retryExceptionalSideEffectWithBackoff(ctx, doPayment, 100, 500)
```

## Observability with Jaeger
Enabling tracing

Having a look at the traces.

## 🏁 The end
What did we cover:
- reliable synchronous calls that can be suspended
- asynchronous calls without the need for queues
- suspensions for external communication
- awakeables: how to do tasks in external systems and resume processing
- durable timers for sleep or for calling other services
- concurrency guarantees of restate for keyed/unkeyed/singleton services
- persistent application state
- state introspection
- storing the results of non-deterministic operations or external calls as side effects
- resiliency: retries
- observability with Jaeger

## Next steps
This tutorial did not cover anything related to deployment. 
In this tutorial, we ran the services as long-running services in Docker containers.
But Restate services can run with minimal changes on AWS Lambda. 

Have a look at these follow-up tutorials:
- Deployment on AWS Lambda
- Deployment on Kubernetes (minikube)




